{"ast":null,"code":"\"use strict\"; // Copyright 2018, Google, LLC.\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _slicedToArray = require(\"/Users/amandapoetker-alles/Desktop/campaign-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/amandapoetker-alles/Desktop/campaign-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/amandapoetker-alles/Desktop/campaign-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction getRetryConfig(err) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var config, retryRanges, shouldRetryFn, delay, backoff;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            config = getConfig(err);\n\n            if (!(!err || !err.config || !config && !err.config.retry)) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\", {\n              shouldRetry: false\n            });\n\n          case 3:\n            config = config || {};\n            config.currentRetryAttempt = config.currentRetryAttempt || 0;\n            config.retry = config.retry === undefined || config.retry === null ? 3 : config.retry;\n            config.retryDelay = config.retryDelay || 100;\n            config.httpMethodsToRetry = config.httpMethodsToRetry || ['GET', 'HEAD', 'PUT', 'OPTIONS', 'DELETE'];\n            config.noResponseRetries = config.noResponseRetries === undefined || config.noResponseRetries === null ? 2 : config.noResponseRetries; // If this wasn't in the list of status codes where we want\n            // to automatically retry, return.\n\n            retryRanges = [// https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n            // 1xx - Retry (Informational, request still processing)\n            // 2xx - Do not retry (Success)\n            // 3xx - Do not retry (Redirect)\n            // 4xx - Do not retry (Client errors)\n            // 429 - Retry (\"Too Many Requests\")\n            // 5xx - Retry (Server errors)\n            [100, 199], [429, 429], [500, 599]];\n            config.statusCodesToRetry = config.statusCodesToRetry || retryRanges; // Put the config back into the err\n\n            err.config.retryConfig = config; // Determine if we should retry the request\n\n            shouldRetryFn = config.shouldRetry || shouldRetryRequest;\n\n            if (shouldRetryFn(err)) {\n              _context.next = 15;\n              break;\n            }\n\n            return _context.abrupt(\"return\", {\n              shouldRetry: false,\n              config: err.config\n            });\n\n          case 15:\n            // Calculate time to wait with exponential backoff.\n            // Formula: (2^c - 1 / 2) * 1000\n            delay = (Math.pow(2, config.currentRetryAttempt) - 1) / 2 * 1000; // We're going to retry!  Incremenent the counter.\n\n            err.config.retryConfig.currentRetryAttempt += 1; // Create a promise that invokes the retry after the backOffDelay\n\n            backoff = new Promise(function (resolve) {\n              setTimeout(resolve, delay);\n            }); // Notify the user if they added an `onRetryAttempt` handler\n\n            if (config.onRetryAttempt) {\n              config.onRetryAttempt(err);\n            } // Return the promise in which recalls Gaxios to retry the request\n\n\n            _context.next = 21;\n            return backoff;\n\n          case 21:\n            return _context.abrupt(\"return\", {\n              shouldRetry: true,\n              config: err.config\n            });\n\n          case 22:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.getRetryConfig = getRetryConfig;\n/**\n * Determine based on config if we should retry the request.\n * @param err The GaxiosError passed to the interceptor.\n */\n\nfunction shouldRetryRequest(err) {\n  var config = getConfig(err); // If there's no config, or retries are disabled, return.\n\n  if (!config || config.retry === 0) {\n    return false;\n  } // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)\n\n\n  if (!err.response && (config.currentRetryAttempt || 0) >= config.noResponseRetries) {\n    return false;\n  } // Only retry with configured HttpMethods.\n\n\n  if (!err.config.method || config.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {\n    return false;\n  } // If this wasn't in the list of status codes where we want\n  // to automatically retry, return.\n\n\n  if (err.response && err.response.status) {\n    var isInRange = false;\n\n    var _iterator = _createForOfIteratorHelper(config.statusCodesToRetry),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            min = _step$value[0],\n            max = _step$value[1];\n\n        var status = err.response.status;\n\n        if (status >= min && status <= max) {\n          isInRange = true;\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (!isInRange) {\n      return false;\n    }\n  } // If we are out of retry attempts, return\n\n\n  config.currentRetryAttempt = config.currentRetryAttempt || 0;\n\n  if (config.currentRetryAttempt >= config.retry) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Acquire the raxConfig object from an GaxiosError if available.\n * @param err The Gaxios error with a config object.\n */\n\n\nfunction getConfig(err) {\n  if (err && err.config && err.config.retryConfig) {\n    return err.config.retryConfig;\n  }\n\n  return;\n}","map":{"version":3,"sources":["../../src/retry.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright 2018, Google, LLC.\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getRetryConfig(err) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let config = getConfig(err);\n        if ((!err || !err.config) || (!config && !err.config.retry)) {\n            return { shouldRetry: false };\n        }\n        config = config || {};\n        config.currentRetryAttempt = config.currentRetryAttempt || 0;\n        config.retry =\n            (config.retry === undefined || config.retry === null) ? 3 : config.retry;\n        config.retryDelay = config.retryDelay || 100;\n        config.httpMethodsToRetry =\n            config.httpMethodsToRetry || ['GET', 'HEAD', 'PUT', 'OPTIONS', 'DELETE'];\n        config.noResponseRetries = (config.noResponseRetries === undefined ||\n            config.noResponseRetries === null) ?\n            2 :\n            config.noResponseRetries;\n        // If this wasn't in the list of status codes where we want\n        // to automatically retry, return.\n        const retryRanges = [\n            // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n            // 1xx - Retry (Informational, request still processing)\n            // 2xx - Do not retry (Success)\n            // 3xx - Do not retry (Redirect)\n            // 4xx - Do not retry (Client errors)\n            // 429 - Retry (\"Too Many Requests\")\n            // 5xx - Retry (Server errors)\n            [100, 199], [429, 429], [500, 599]\n        ];\n        config.statusCodesToRetry = config.statusCodesToRetry || retryRanges;\n        // Put the config back into the err\n        err.config.retryConfig = config;\n        // Determine if we should retry the request\n        const shouldRetryFn = config.shouldRetry || shouldRetryRequest;\n        if (!shouldRetryFn(err)) {\n            return { shouldRetry: false, config: err.config };\n        }\n        // Calculate time to wait with exponential backoff.\n        // Formula: (2^c - 1 / 2) * 1000\n        const delay = (Math.pow(2, config.currentRetryAttempt) - 1) / 2 * 1000;\n        // We're going to retry!  Incremenent the counter.\n        err.config.retryConfig.currentRetryAttempt += 1;\n        // Create a promise that invokes the retry after the backOffDelay\n        const backoff = new Promise(resolve => {\n            setTimeout(resolve, delay);\n        });\n        // Notify the user if they added an `onRetryAttempt` handler\n        if (config.onRetryAttempt) {\n            config.onRetryAttempt(err);\n        }\n        // Return the promise in which recalls Gaxios to retry the request\n        yield backoff;\n        return { shouldRetry: true, config: err.config };\n    });\n}\nexports.getRetryConfig = getRetryConfig;\n/**\n * Determine based on config if we should retry the request.\n * @param err The GaxiosError passed to the interceptor.\n */\nfunction shouldRetryRequest(err) {\n    const config = getConfig(err);\n    // If there's no config, or retries are disabled, return.\n    if (!config || config.retry === 0) {\n        return false;\n    }\n    // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)\n    if (!err.response &&\n        ((config.currentRetryAttempt || 0) >= config.noResponseRetries)) {\n        return false;\n    }\n    // Only retry with configured HttpMethods.\n    if (!err.config.method ||\n        config.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {\n        return false;\n    }\n    // If this wasn't in the list of status codes where we want\n    // to automatically retry, return.\n    if (err.response && err.response.status) {\n        let isInRange = false;\n        for (const [min, max] of config.statusCodesToRetry) {\n            const status = err.response.status;\n            if (status >= min && status <= max) {\n                isInRange = true;\n                break;\n            }\n        }\n        if (!isInRange) {\n            return false;\n        }\n    }\n    // If we are out of retry attempts, return\n    config.currentRetryAttempt = config.currentRetryAttempt || 0;\n    if (config.currentRetryAttempt >= config.retry) {\n        return false;\n    }\n    return true;\n}\n/**\n * Acquire the raxConfig object from an GaxiosError if available.\n * @param err The Gaxios error with a config object.\n */\nfunction getConfig(err) {\n    if (err && err.config && err.config.retryConfig) {\n        return err.config.retryConfig;\n    }\n    return;\n}\n//# sourceMappingURL=retry.js.map"]},"metadata":{},"sourceType":"script"}