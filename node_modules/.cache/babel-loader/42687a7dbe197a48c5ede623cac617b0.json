{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _createForOfIteratorHelper = require(\"/Users/amandapoetker-alles/Desktop/campaign-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/amandapoetker-alles/Desktop/campaign-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/amandapoetker-alles/Desktop/campaign-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/amandapoetker-alles/Desktop/campaign-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/amandapoetker-alles/Desktop/campaign-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/amandapoetker-alles/Desktop/campaign-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar querystring = require(\"querystring\");\n\nvar stream = require(\"stream\");\n\nvar crypto_1 = require(\"../crypto/crypto\");\n\nvar isbrowser_1 = require(\"../isbrowser\");\n\nvar messages = require(\"../messages\");\n\nvar authclient_1 = require(\"./authclient\");\n\nvar loginticket_1 = require(\"./loginticket\");\n\nvar CodeChallengeMethod;\n\n(function (CodeChallengeMethod) {\n  CodeChallengeMethod[\"Plain\"] = \"plain\";\n  CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\n\nvar CertificateFormat;\n\n(function (CertificateFormat) {\n  CertificateFormat[\"PEM\"] = \"PEM\";\n  CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\n\nvar OAuth2Client = /*#__PURE__*/function (_authclient_1$AuthCli) {\n  _inherits(OAuth2Client, _authclient_1$AuthCli);\n\n  var _super = _createSuper(OAuth2Client);\n\n  function OAuth2Client(optionsOrClientId, clientSecret, redirectUri) {\n    var _this;\n\n    _classCallCheck(this, OAuth2Client);\n\n    _this = _super.call(this);\n    _this.certificateCache = {};\n    _this.certificateExpiry = null;\n    _this.certificateCacheFormat = CertificateFormat.PEM;\n    _this.refreshTokenPromises = new Map();\n    var opts = optionsOrClientId && typeof optionsOrClientId === 'object' ? optionsOrClientId : {\n      clientId: optionsOrClientId,\n      clientSecret,\n      redirectUri\n    };\n    _this._clientId = opts.clientId;\n    _this._clientSecret = opts.clientSecret;\n    _this.redirectUri = opts.redirectUri;\n    _this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n    return _this;\n  }\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n\n\n  _createClass(OAuth2Client, [{\n    key: \"generateAuthUrl\",\n    value: function generateAuthUrl() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (opts.code_challenge_method && !opts.code_challenge) {\n        throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n      }\n\n      opts.response_type = opts.response_type || 'code';\n      opts.client_id = opts.client_id || this._clientId;\n      opts.redirect_uri = opts.redirect_uri || this.redirectUri; // Allow scopes to be passed either as array or a string\n\n      if (opts.scope instanceof Array) {\n        opts.scope = opts.scope.join(' ');\n      }\n\n      var rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n      return rootUrl + '?' + querystring.stringify(opts);\n    }\n  }, {\n    key: \"generateCodeVerifier\",\n    value: function generateCodeVerifier() {\n      // To make the code compatible with browser SubtleCrypto we need to make\n      // this method async.\n      throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and it's\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     */\n\n  }, {\n    key: \"generateCodeVerifierAsync\",\n    value: function generateCodeVerifierAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var crypto, randomString, codeVerifier, unencodedCodeChallenge, codeChallenge;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // base64 encoding uses 6 bits per character, and we want to generate128\n                // characters. 6*128/8 = 96.\n                crypto = crypto_1.createCrypto();\n                randomString = crypto.randomBytesBase64(96); // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n                // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n                // swapping out a few chars.\n\n                codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-'); // Generate the base64 encoded SHA256\n\n                _context.next = 5;\n                return crypto.sha256DigestBase64(codeVerifier);\n\n              case 5:\n                unencodedCodeChallenge = _context.sent;\n                // We need to use base64UrlEncoding instead of standard base64\n                codeChallenge = unencodedCodeChallenge.split('=')[0].replace(/\\+/g, '-').replace(/\\//g, '_');\n                return _context.abrupt(\"return\", {\n                  codeVerifier,\n                  codeChallenge\n                });\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n  }, {\n    key: \"getToken\",\n    value: function getToken(codeOrOptions, callback) {\n      var options = typeof codeOrOptions === 'string' ? {\n        code: codeOrOptions\n      } : codeOrOptions;\n\n      if (callback) {\n        this.getTokenAsync(options).then(function (r) {\n          return callback(null, r.tokens, r.res);\n        }, function (e) {\n          return callback(e, null, e.response);\n        });\n      } else {\n        return this.getTokenAsync(options);\n      }\n    }\n  }, {\n    key: \"getTokenAsync\",\n    value: function getTokenAsync(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var url, values, res, tokens;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n                values = {\n                  code: options.code,\n                  client_id: options.client_id || this._clientId,\n                  client_secret: this._clientSecret,\n                  redirect_uri: options.redirect_uri || this.redirectUri,\n                  grant_type: 'authorization_code',\n                  code_verifier: options.codeVerifier\n                };\n                _context2.next = 4;\n                return this.transporter.request({\n                  method: 'POST',\n                  url,\n                  data: querystring.stringify(values),\n                  headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                  }\n                });\n\n              case 4:\n                res = _context2.sent;\n                tokens = res.data;\n\n                if (res.data && res.data.expires_in) {\n                  tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n                  delete tokens.expires_in;\n                }\n\n                this.emit('tokens', tokens);\n                return _context2.abrupt(\"return\", {\n                  tokens,\n                  res\n                });\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */\n\n  }, {\n    key: \"refreshToken\",\n    value: function refreshToken(_refreshToken) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        var p;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (_refreshToken) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this.refreshTokenNoCache(_refreshToken));\n\n              case 2:\n                if (!this.refreshTokenPromises.has(_refreshToken)) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this.refreshTokenPromises.get(_refreshToken));\n\n              case 4:\n                p = this.refreshTokenNoCache(_refreshToken).then(function (r) {\n                  _this2.refreshTokenPromises.delete(_refreshToken);\n\n                  return r;\n                }, function (e) {\n                  _this2.refreshTokenPromises.delete(_refreshToken);\n\n                  throw e;\n                });\n                this.refreshTokenPromises.set(_refreshToken, p);\n                return _context3.abrupt(\"return\", p);\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"refreshTokenNoCache\",\n    value: function refreshTokenNoCache(refreshToken) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var url, data, res, tokens;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n                data = {\n                  refresh_token: refreshToken,\n                  client_id: this._clientId,\n                  client_secret: this._clientSecret,\n                  grant_type: 'refresh_token'\n                }; // request for new token\n\n                _context4.next = 4;\n                return this.transporter.request({\n                  method: 'POST',\n                  url,\n                  data: querystring.stringify(data),\n                  headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                  }\n                });\n\n              case 4:\n                res = _context4.sent;\n                tokens = res.data; // TODO: de-duplicate this code from a few spots\n\n                if (res.data && res.data.expires_in) {\n                  tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n                  delete tokens.expires_in;\n                }\n\n                this.emit('tokens', tokens);\n                return _context4.abrupt(\"return\", {\n                  tokens,\n                  res\n                });\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"refreshAccessToken\",\n    value: function refreshAccessToken(callback) {\n      messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n\n      if (callback) {\n        this.refreshAccessTokenAsync().then(function (r) {\n          return callback(null, r.credentials, r.res);\n        }, callback);\n      } else {\n        return this.refreshAccessTokenAsync();\n      }\n    }\n  }, {\n    key: \"refreshAccessTokenAsync\",\n    value: function refreshAccessTokenAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var r, tokens;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this.credentials.refresh_token) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw new Error('No refresh token is set.');\n\n              case 2:\n                _context5.next = 4;\n                return this.refreshToken(this.credentials.refresh_token);\n\n              case 4:\n                r = _context5.sent;\n                tokens = r.tokens;\n                tokens.refresh_token = this.credentials.refresh_token;\n                this.credentials = tokens;\n                return _context5.abrupt(\"return\", {\n                  credentials: this.credentials,\n                  res: r.res\n                });\n\n              case 9:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n  }, {\n    key: \"getAccessToken\",\n    value: function getAccessToken(callback) {\n      if (callback) {\n        this.getAccessTokenAsync().then(function (r) {\n          return callback(null, r.token, r.res);\n        }, callback);\n      } else {\n        return this.getAccessTokenAsync();\n      }\n    }\n  }, {\n    key: \"getAccessTokenAsync\",\n    value: function getAccessTokenAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var shouldRefresh, r;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n\n                if (!shouldRefresh) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                if (this.credentials.refresh_token) {\n                  _context6.next = 4;\n                  break;\n                }\n\n                throw new Error('No refresh token is set.');\n\n              case 4:\n                _context6.next = 6;\n                return this.refreshAccessTokenAsync();\n\n              case 6:\n                r = _context6.sent;\n\n                if (!(!r.credentials || r.credentials && !r.credentials.access_token)) {\n                  _context6.next = 9;\n                  break;\n                }\n\n                throw new Error('Could not refresh access token.');\n\n              case 9:\n                return _context6.abrupt(\"return\", {\n                  token: r.credentials.access_token,\n                  res: r.res\n                });\n\n              case 12:\n                return _context6.abrupt(\"return\", {\n                  token: this.credentials.access_token\n                });\n\n              case 13:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"getRequestMetadata\",\n    value: function getRequestMetadata(url, callback) {\n      messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n\n      if (callback) {\n        this.getRequestMetadataAsync(url).then(function (r) {\n          return callback(null, r.headers, r.res);\n        }, callback);\n      } else {\n        return this.getRequestMetadataAsync();\n      }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */\n\n  }, {\n    key: \"getRequestHeaders\",\n    value: function getRequestHeaders(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var res;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.getRequestMetadataAsync(url);\n\n              case 2:\n                res = _context7.sent;\n                return _context7.abrupt(\"return\", res.headers);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n  }, {\n    key: \"getRequestMetadataAsync\",\n    value: function getRequestMetadataAsync(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var thisCreds, _headers, r, tokens, e, credentials, headers;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                thisCreds = this.credentials;\n\n                if (!(!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey)) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                throw new Error('No access, refresh token or API key is set.');\n\n              case 3:\n                if (!(thisCreds.access_token && !this.isTokenExpiring())) {\n                  _context8.next = 7;\n                  break;\n                }\n\n                thisCreds.token_type = thisCreds.token_type || 'Bearer';\n                _headers = {\n                  Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n                };\n                return _context8.abrupt(\"return\", {\n                  headers: _headers\n                });\n\n              case 7:\n                if (!this.apiKey) {\n                  _context8.next = 9;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", {\n                  headers: {}\n                });\n\n              case 9:\n                r = null;\n                tokens = null;\n                _context8.prev = 11;\n                _context8.next = 14;\n                return this.refreshToken(thisCreds.refresh_token);\n\n              case 14:\n                r = _context8.sent;\n                tokens = r.tokens;\n                _context8.next = 23;\n                break;\n\n              case 18:\n                _context8.prev = 18;\n                _context8.t0 = _context8[\"catch\"](11);\n                e = _context8.t0;\n\n                if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n                  e.message = 'Could not refresh access token.';\n                }\n\n                throw e;\n\n              case 23:\n                credentials = this.credentials;\n                credentials.token_type = credentials.token_type || 'Bearer';\n                tokens.refresh_token = credentials.refresh_token;\n                this.credentials = tokens;\n                headers = {\n                  Authorization: credentials.token_type + ' ' + tokens.access_token\n                };\n                return _context8.abrupt(\"return\", {\n                  headers,\n                  res: r.res\n                });\n\n              case 29:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[11, 18]]);\n      }));\n    }\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     */\n\n  }, {\n    key: \"revokeToken\",\n    value: function revokeToken(token, callback) {\n      var opts = {\n        url: OAuth2Client.getRevokeTokenUrl(token),\n        method: 'POST'\n      };\n\n      if (callback) {\n        this.transporter.request(opts).then(function (r) {\n          return callback(null, r);\n        }, callback);\n      } else {\n        return this.transporter.request(opts);\n      }\n    }\n  }, {\n    key: \"revokeCredentials\",\n    value: function revokeCredentials(callback) {\n      if (callback) {\n        this.revokeCredentialsAsync().then(function (res) {\n          return callback(null, res);\n        }, callback);\n      } else {\n        return this.revokeCredentialsAsync();\n      }\n    }\n  }, {\n    key: \"revokeCredentialsAsync\",\n    value: function revokeCredentialsAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var token;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                token = this.credentials.access_token;\n                this.credentials = {};\n\n                if (!token) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", this.revokeToken(token));\n\n              case 6:\n                throw new Error('No access token to revoke.');\n\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n  }, {\n    key: \"request\",\n    value: function request(opts, callback) {\n      if (callback) {\n        this.requestAsync(opts).then(function (r) {\n          return callback(null, r);\n        }, function (e) {\n          return callback(e, e.response);\n        });\n      } else {\n        return this.requestAsync(opts);\n      }\n    }\n  }, {\n    key: \"requestAsync\",\n    value: function requestAsync(opts) {\n      var retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var r2, r, res, statusCode, mayRequireRefresh, isReadableStream, isAuthErr;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.prev = 0;\n                _context10.next = 3;\n                return this.getRequestMetadataAsync(opts.url);\n\n              case 3:\n                r = _context10.sent;\n\n                if (r.headers && r.headers.Authorization) {\n                  opts.headers = opts.headers || {};\n                  opts.headers.Authorization = r.headers.Authorization;\n                }\n\n                if (this.apiKey) {\n                  opts.params = Object.assign(opts.params || {}, {\n                    key: this.apiKey\n                  });\n                }\n\n                _context10.next = 8;\n                return this.transporter.request(opts);\n\n              case 8:\n                r2 = _context10.sent;\n                _context10.next = 24;\n                break;\n\n              case 11:\n                _context10.prev = 11;\n                _context10.t0 = _context10[\"catch\"](0);\n                res = _context10.t0.response;\n\n                if (!res) {\n                  _context10.next = 23;\n                  break;\n                }\n\n                statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - An access_token and refresh_token were available, but no\n                //   expiry_date was availabe. This can happen when developers stash\n                //   the access_token and refresh_token for later use, but the\n                //   access_token fails on the first try because it's expired.\n\n                mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && !this.credentials.expiry_date;\n                isReadableStream = res.config.data instanceof stream.Readable;\n                isAuthErr = statusCode === 401 || statusCode === 403;\n\n                if (!(!retry && isAuthErr && !isReadableStream && mayRequireRefresh)) {\n                  _context10.next = 23;\n                  break;\n                }\n\n                _context10.next = 22;\n                return this.refreshAccessTokenAsync();\n\n              case 22:\n                return _context10.abrupt(\"return\", this.requestAsync(opts, true));\n\n              case 23:\n                throw _context10.t0;\n\n              case 24:\n                return _context10.abrupt(\"return\", r2);\n\n              case 25:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[0, 11]]);\n      }));\n    }\n  }, {\n    key: \"verifyIdToken\",\n    value: function verifyIdToken(options, callback) {\n      // This function used to accept two arguments instead of an options object.\n      // Check the types to help users upgrade with less pain.\n      // This check can be removed after a 2.0 release.\n      if (callback && typeof callback !== 'function') {\n        throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n      }\n\n      if (callback) {\n        this.verifyIdTokenAsync(options).then(function (r) {\n          return callback(null, r);\n        }, callback);\n      } else {\n        return this.verifyIdTokenAsync(options);\n      }\n    }\n  }, {\n    key: \"verifyIdTokenAsync\",\n    value: function verifyIdTokenAsync(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n        var response, login;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (options.idToken) {\n                  _context11.next = 2;\n                  break;\n                }\n\n                throw new Error('The verifyIdToken method requires an ID Token');\n\n              case 2:\n                _context11.next = 4;\n                return this.getFederatedSignonCertsAsync();\n\n              case 4:\n                response = _context11.sent;\n                _context11.next = 7;\n                return this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n\n              case 7:\n                login = _context11.sent;\n                return _context11.abrupt(\"return\", login);\n\n              case 9:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */\n\n  }, {\n    key: \"getTokenInfo\",\n    value: function getTokenInfo(accessToken) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var _yield$this$transport, data, info;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.transporter.request({\n                  method: 'GET',\n                  url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n                  params: {\n                    access_token: accessToken\n                  }\n                });\n\n              case 2:\n                _yield$this$transport = _context12.sent;\n                data = _yield$this$transport.data;\n                info = Object.assign({\n                  expiry_date: new Date().getTime() + data.expires_in * 1000,\n                  scopes: data.scope.split(' ')\n                }, data);\n                delete info.expires_in;\n                delete info.scope;\n                return _context12.abrupt(\"return\", info);\n\n              case 8:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n    }\n  }, {\n    key: \"getFederatedSignonCerts\",\n    value: function getFederatedSignonCerts(callback) {\n      if (callback) {\n        this.getFederatedSignonCertsAsync().then(function (r) {\n          return callback(null, r.certs, r.res);\n        }, callback);\n      } else {\n        return this.getFederatedSignonCertsAsync();\n      }\n    }\n  }, {\n    key: \"getFederatedSignonCertsAsync\",\n    value: function getFederatedSignonCertsAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var nowTime, format, res, url, cacheControl, cacheAge, pattern, regexResult, certificates, _iterator, _step, key, now;\n\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                nowTime = new Date().getTime();\n                format = isbrowser_1.isBrowser() ? CertificateFormat.JWK : CertificateFormat.PEM;\n\n                if (!(this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format)) {\n                  _context13.next = 4;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", {\n                  certs: this.certificateCache,\n                  format\n                });\n\n              case 4:\n                _context13.t0 = format;\n                _context13.next = _context13.t0 === CertificateFormat.PEM ? 7 : _context13.t0 === CertificateFormat.JWK ? 9 : 11;\n                break;\n\n              case 7:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n                return _context13.abrupt(\"break\", 12);\n\n              case 9:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n                return _context13.abrupt(\"break\", 12);\n\n              case 11:\n                throw new Error(\"Unsupported certificate format \".concat(format));\n\n              case 12:\n                _context13.prev = 12;\n                _context13.next = 15;\n                return this.transporter.request({\n                  url\n                });\n\n              case 15:\n                res = _context13.sent;\n                _context13.next = 21;\n                break;\n\n              case 18:\n                _context13.prev = 18;\n                _context13.t1 = _context13[\"catch\"](12);\n                throw new Error('Failed to retrieve verification certificates: ' + _context13.t1);\n\n              case 21:\n                cacheControl = res ? res.headers['cache-control'] : undefined;\n                cacheAge = -1;\n\n                if (cacheControl) {\n                  pattern = new RegExp('max-age=([0-9]*)');\n                  regexResult = pattern.exec(cacheControl);\n\n                  if (regexResult && regexResult.length === 2) {\n                    // Cache results with max-age (in seconds)\n                    cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n                  }\n                }\n\n                certificates = {};\n                _context13.t2 = format;\n                _context13.next = _context13.t2 === CertificateFormat.PEM ? 28 : _context13.t2 === CertificateFormat.JWK ? 30 : 33;\n                break;\n\n              case 28:\n                certificates = res.data;\n                return _context13.abrupt(\"break\", 34);\n\n              case 30:\n                _iterator = _createForOfIteratorHelper(res.data.keys);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    key = _step.value;\n                    certificates[key.kid] = key;\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                return _context13.abrupt(\"break\", 34);\n\n              case 33:\n                throw new Error(\"Unsupported certificate format \".concat(format));\n\n              case 34:\n                now = new Date();\n                this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n                this.certificateCache = certificates;\n                this.certificateCacheFormat = format;\n                return _context13.abrupt(\"return\", {\n                  certs: certificates,\n                  format,\n                  res\n                });\n\n              case 39:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[12, 18]]);\n      }));\n    }\n  }, {\n    key: \"verifySignedJwtWithCerts\",\n    value: function verifySignedJwtWithCerts() {\n      // To make the code compatible with browser SubtleCrypto we need to make\n      // this method async.\n      throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */\n\n  }, {\n    key: \"verifySignedJwtWithCertsAsync\",\n    value: function verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        var crypto, segments, signed, signature, envelope, payload, cert, verified, iat, exp, now, earliest, latest, aud, audVerified;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                crypto = crypto_1.createCrypto();\n\n                if (!maxExpiry) {\n                  maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n                }\n\n                segments = jwt.split('.');\n\n                if (!(segments.length !== 3)) {\n                  _context14.next = 5;\n                  break;\n                }\n\n                throw new Error('Wrong number of segments in token: ' + jwt);\n\n              case 5:\n                signed = segments[0] + '.' + segments[1];\n                signature = segments[2];\n                _context14.prev = 7;\n                envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n                _context14.next = 14;\n                break;\n\n              case 11:\n                _context14.prev = 11;\n                _context14.t0 = _context14[\"catch\"](7);\n                throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n\n              case 14:\n                if (envelope) {\n                  _context14.next = 16;\n                  break;\n                }\n\n                throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n\n              case 16:\n                _context14.prev = 16;\n                payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n                _context14.next = 23;\n                break;\n\n              case 20:\n                _context14.prev = 20;\n                _context14.t1 = _context14[\"catch\"](16);\n                throw new Error('Can\\'t parse token payload: ' + segments[0]);\n\n              case 23:\n                if (payload) {\n                  _context14.next = 25;\n                  break;\n                }\n\n                throw new Error('Can\\'t parse token payload: ' + segments[1]);\n\n              case 25:\n                if (certs.hasOwnProperty(envelope.kid)) {\n                  _context14.next = 27;\n                  break;\n                }\n\n                throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n\n              case 27:\n                cert = certs[envelope.kid];\n                _context14.next = 30;\n                return crypto.verify(cert, signed, signature);\n\n              case 30:\n                verified = _context14.sent;\n\n                if (verified) {\n                  _context14.next = 33;\n                  break;\n                }\n\n                throw new Error('Invalid token signature: ' + jwt);\n\n              case 33:\n                if (payload.iat) {\n                  _context14.next = 35;\n                  break;\n                }\n\n                throw new Error('No issue time in token: ' + JSON.stringify(payload));\n\n              case 35:\n                if (payload.exp) {\n                  _context14.next = 37;\n                  break;\n                }\n\n                throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n\n              case 37:\n                iat = Number(payload.iat);\n\n                if (!isNaN(iat)) {\n                  _context14.next = 40;\n                  break;\n                }\n\n                throw new Error('iat field using invalid format');\n\n              case 40:\n                exp = Number(payload.exp);\n\n                if (!isNaN(exp)) {\n                  _context14.next = 43;\n                  break;\n                }\n\n                throw new Error('exp field using invalid format');\n\n              case 43:\n                now = new Date().getTime() / 1000;\n\n                if (!(exp >= now + maxExpiry)) {\n                  _context14.next = 46;\n                  break;\n                }\n\n                throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n\n              case 46:\n                earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n                latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n                if (!(now < earliest)) {\n                  _context14.next = 50;\n                  break;\n                }\n\n                throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n\n              case 50:\n                if (!(now > latest)) {\n                  _context14.next = 52;\n                  break;\n                }\n\n                throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n\n              case 52:\n                if (!(issuers && issuers.indexOf(payload.iss) < 0)) {\n                  _context14.next = 54;\n                  break;\n                }\n\n                throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n\n              case 54:\n                if (!(typeof requiredAudience !== 'undefined' && requiredAudience !== null)) {\n                  _context14.next = 60;\n                  break;\n                }\n\n                aud = payload.aud;\n                audVerified = false; // If the requiredAudience is an array, check if it contains token\n                // audience\n\n                if (requiredAudience.constructor === Array) {\n                  audVerified = requiredAudience.indexOf(aud) > -1;\n                } else {\n                  audVerified = aud === requiredAudience;\n                }\n\n                if (audVerified) {\n                  _context14.next = 60;\n                  break;\n                }\n\n                throw new Error('Wrong recipient, payload audience != requiredAudience');\n\n              case 60:\n                return _context14.abrupt(\"return\", new loginticket_1.LoginTicket(envelope, payload));\n\n              case 61:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, null, [[7, 11], [16, 20]]);\n      }));\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */\n\n  }, {\n    key: \"isTokenExpiring\",\n    value: function isTokenExpiring() {\n      var expiryDate = this.credentials.expiry_date;\n      return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n    }\n  }], [{\n    key: \"getRevokeTokenUrl\",\n    value: function getRevokeTokenUrl(token) {\n      var parameters = querystring.stringify({\n        token\n      });\n      return \"\".concat(OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_, \"?\").concat(parameters);\n    }\n  }]);\n\n  return OAuth2Client;\n}(authclient_1.AuthClient);\n\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Clock skew - five minutes in seconds\n */\n\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\n\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\n\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];\nexports.OAuth2Client = OAuth2Client;","map":{"version":3,"sources":["/Users/amandapoetker-alles/Desktop/campaign-dashboard/node_modules/google-auth-library/build/src/auth/oauth2client.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","querystring","require","stream","crypto_1","isbrowser_1","messages","authclient_1","loginticket_1","CodeChallengeMethod","CertificateFormat","OAuth2Client","optionsOrClientId","clientSecret","redirectUri","certificateCache","certificateExpiry","certificateCacheFormat","PEM","refreshTokenPromises","Map","opts","clientId","_clientId","_clientSecret","eagerRefreshThresholdMillis","code_challenge_method","code_challenge","Error","response_type","client_id","redirect_uri","scope","Array","join","rootUrl","GOOGLE_OAUTH2_AUTH_BASE_URL_","stringify","crypto","createCrypto","randomString","randomBytesBase64","codeVerifier","replace","sha256DigestBase64","unencodedCodeChallenge","codeChallenge","split","codeOrOptions","callback","options","code","getTokenAsync","r","tokens","res","response","url","GOOGLE_OAUTH2_TOKEN_URL_","values","client_secret","grant_type","code_verifier","transporter","request","method","data","headers","expires_in","expiry_date","Date","getTime","emit","refreshToken","refreshTokenNoCache","has","get","p","delete","set","refresh_token","warn","REFRESH_ACCESS_TOKEN_DEPRECATED","refreshAccessTokenAsync","credentials","getAccessTokenAsync","token","shouldRefresh","access_token","isTokenExpiring","OAUTH_GET_REQUEST_METADATA_DEPRECATED","getRequestMetadataAsync","thisCreds","apiKey","token_type","Authorization","status","message","getRevokeTokenUrl","revokeCredentialsAsync","revokeToken","requestAsync","retry","params","assign","key","r2","statusCode","mayRequireRefresh","isReadableStream","config","Readable","isAuthErr","verifyIdTokenAsync","idToken","getFederatedSignonCertsAsync","verifySignedJwtWithCertsAsync","certs","audience","ISSUERS_","maxExpiry","login","accessToken","GOOGLE_TOKEN_INFO_URL","info","scopes","nowTime","format","isBrowser","JWK","GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_","GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_","cacheControl","undefined","cacheAge","pattern","RegExp","regexResult","exec","length","Number","certificates","keys","kid","now","jwt","requiredAudience","issuers","MAX_TOKEN_LIFETIME_SECS_","segments","signed","signature","envelope","JSON","parse","decodeBase64StringUtf8","payload","hasOwnProperty","cert","verify","verified","iat","exp","isNaN","earliest","CLOCK_SKEW_SECS_","latest","indexOf","iss","aud","audVerified","constructor","LoginTicket","expiryDate","parameters","GOOGLE_OAUTH2_REVOKE_URL_","AuthClient"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst querystring = require(\"querystring\");\nconst stream = require(\"stream\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst isbrowser_1 = require(\"../isbrowser\");\nconst messages = require(\"../messages\");\nconst authclient_1 = require(\"./authclient\");\nconst loginticket_1 = require(\"./loginticket\");\nvar CodeChallengeMethod;\n(function (CodeChallengeMethod) {\n    CodeChallengeMethod[\"Plain\"] = \"plain\";\n    CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function (CertificateFormat) {\n    CertificateFormat[\"PEM\"] = \"PEM\";\n    CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\nclass OAuth2Client extends authclient_1.AuthClient {\n    constructor(optionsOrClientId, clientSecret, redirectUri) {\n        super();\n        this.certificateCache = {};\n        this.certificateExpiry = null;\n        this.certificateCacheFormat = CertificateFormat.PEM;\n        this.refreshTokenPromises = new Map();\n        const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n            optionsOrClientId :\n            { clientId: optionsOrClientId, clientSecret, redirectUri };\n        this._clientId = opts.clientId;\n        this._clientSecret = opts.clientSecret;\n        this.redirectUri = opts.redirectUri;\n        this.eagerRefreshThresholdMillis =\n            opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n    }\n    /**\n     * Generates URL for consent page landing.\n     * @param opts Options.\n     * @return URL to consent page.\n     */\n    generateAuthUrl(opts = {}) {\n        if (opts.code_challenge_method && !opts.code_challenge) {\n            throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n        }\n        opts.response_type = opts.response_type || 'code';\n        opts.client_id = opts.client_id || this._clientId;\n        opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n        // Allow scopes to be passed either as array or a string\n        if (opts.scope instanceof Array) {\n            opts.scope = opts.scope.join(' ');\n        }\n        const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n        return rootUrl + '?' + querystring.stringify(opts);\n    }\n    generateCodeVerifier() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and it's\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     */\n    generateCodeVerifierAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // base64 encoding uses 6 bits per character, and we want to generate128\n            // characters. 6*128/8 = 96.\n            const crypto = crypto_1.createCrypto();\n            const randomString = crypto.randomBytesBase64(96);\n            // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n            // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n            // swapping out a few chars.\n            const codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n            // Generate the base64 encoded SHA256\n            const unencodedCodeChallenge = yield crypto.sha256DigestBase64(codeVerifier);\n            // We need to use base64UrlEncoding instead of standard base64\n            const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                .replace(/\\+/g, '-')\n                .replace(/\\//g, '_');\n            return { codeVerifier, codeChallenge };\n        });\n    }\n    getToken(codeOrOptions, callback) {\n        const options = (typeof codeOrOptions === 'string') ?\n            { code: codeOrOptions } :\n            codeOrOptions;\n        if (callback) {\n            this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n        }\n        else {\n            return this.getTokenAsync(options);\n        }\n    }\n    getTokenAsync(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n            const values = {\n                code: options.code,\n                client_id: options.client_id || this._clientId,\n                client_secret: this._clientSecret,\n                redirect_uri: options.redirect_uri || this.redirectUri,\n                grant_type: 'authorization_code',\n                code_verifier: options.codeVerifier\n            };\n            const res = yield this.transporter.request({\n                method: 'POST',\n                url,\n                data: querystring.stringify(values),\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n            });\n            const tokens = res.data;\n            if (res.data && res.data.expires_in) {\n                tokens.expiry_date =\n                    ((new Date()).getTime() + (res.data.expires_in * 1000));\n                delete tokens.expires_in;\n            }\n            this.emit('tokens', tokens);\n            return { tokens, res };\n        });\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */\n    refreshToken(refreshToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!refreshToken) {\n                return this.refreshTokenNoCache(refreshToken);\n            }\n            // If a request to refresh using the same token has started,\n            // return the same promise.\n            if (this.refreshTokenPromises.has(refreshToken)) {\n                return this.refreshTokenPromises.get(refreshToken);\n            }\n            const p = this.refreshTokenNoCache(refreshToken)\n                .then(r => {\n                this.refreshTokenPromises.delete(refreshToken);\n                return r;\n            }, e => {\n                this.refreshTokenPromises.delete(refreshToken);\n                throw e;\n            });\n            this.refreshTokenPromises.set(refreshToken, p);\n            return p;\n        });\n    }\n    refreshTokenNoCache(refreshToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n            const data = {\n                refresh_token: refreshToken,\n                client_id: this._clientId,\n                client_secret: this._clientSecret,\n                grant_type: 'refresh_token'\n            };\n            // request for new token\n            const res = yield this.transporter.request({\n                method: 'POST',\n                url,\n                data: querystring.stringify(data),\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n            });\n            const tokens = res.data;\n            // TODO: de-duplicate this code from a few spots\n            if (res.data && res.data.expires_in) {\n                tokens.expiry_date =\n                    ((new Date()).getTime() + (res.data.expires_in * 1000));\n                delete tokens.expires_in;\n            }\n            this.emit('tokens', tokens);\n            return { tokens, res };\n        });\n    }\n    refreshAccessToken(callback) {\n        messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n        if (callback) {\n            this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n        }\n        else {\n            return this.refreshAccessTokenAsync();\n        }\n    }\n    refreshAccessTokenAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.credentials.refresh_token) {\n                throw new Error('No refresh token is set.');\n            }\n            const r = yield this.refreshToken(this.credentials.refresh_token);\n            const tokens = r.tokens;\n            tokens.refresh_token = this.credentials.refresh_token;\n            this.credentials = tokens;\n            return { credentials: this.credentials, res: r.res };\n        });\n    }\n    getAccessToken(callback) {\n        if (callback) {\n            this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n        }\n        else {\n            return this.getAccessTokenAsync();\n        }\n    }\n    getAccessTokenAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n            if (shouldRefresh) {\n                if (!this.credentials.refresh_token) {\n                    throw new Error('No refresh token is set.');\n                }\n                const r = yield this.refreshAccessTokenAsync();\n                if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n                    throw new Error('Could not refresh access token.');\n                }\n                return { token: r.credentials.access_token, res: r.res };\n            }\n            else {\n                return { token: this.credentials.access_token };\n            }\n        });\n    }\n    getRequestMetadata(url, callback) {\n        messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n        if (callback) {\n            this.getRequestMetadataAsync(url).then(r => callback(null, r.headers, r.res), callback);\n        }\n        else {\n            return this.getRequestMetadataAsync();\n        }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */\n    getRequestHeaders(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const res = yield this.getRequestMetadataAsync(url);\n            return res.headers;\n        });\n    }\n    getRequestMetadataAsync(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const thisCreds = this.credentials;\n            if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n                throw new Error('No access, refresh token or API key is set.');\n            }\n            if (thisCreds.access_token && !this.isTokenExpiring()) {\n                thisCreds.token_type = thisCreds.token_type || 'Bearer';\n                const headers = {\n                    Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n                };\n                return { headers };\n            }\n            if (this.apiKey) {\n                return { headers: {} };\n            }\n            let r = null;\n            let tokens = null;\n            try {\n                r = yield this.refreshToken(thisCreds.refresh_token);\n                tokens = r.tokens;\n            }\n            catch (err) {\n                const e = err;\n                if (e.response &&\n                    (e.response.status === 403 || e.response.status === 404)) {\n                    e.message = 'Could not refresh access token.';\n                }\n                throw e;\n            }\n            const credentials = this.credentials;\n            credentials.token_type = credentials.token_type || 'Bearer';\n            tokens.refresh_token = credentials.refresh_token;\n            this.credentials = tokens;\n            const headers = {\n                Authorization: credentials.token_type + ' ' + tokens.access_token\n            };\n            return { headers, res: r.res };\n        });\n    }\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     */\n    static getRevokeTokenUrl(token) {\n        const parameters = querystring.stringify({ token });\n        return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\n    }\n    revokeToken(token, callback) {\n        const opts = {\n            url: OAuth2Client.getRevokeTokenUrl(token),\n            method: 'POST'\n        };\n        if (callback) {\n            this.transporter.request(opts).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.transporter.request(opts);\n        }\n    }\n    revokeCredentials(callback) {\n        if (callback) {\n            this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n        }\n        else {\n            return this.revokeCredentialsAsync();\n        }\n    }\n    revokeCredentialsAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const token = this.credentials.access_token;\n            this.credentials = {};\n            if (token) {\n                return this.revokeToken(token);\n            }\n            else {\n                throw new Error('No access token to revoke.');\n            }\n        });\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    requestAsync(opts, retry = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let r2;\n            try {\n                const r = yield this.getRequestMetadataAsync(opts.url);\n                if (r.headers && r.headers.Authorization) {\n                    opts.headers = opts.headers || {};\n                    opts.headers.Authorization = r.headers.Authorization;\n                }\n                if (this.apiKey) {\n                    opts.params = Object.assign(opts.params || {}, { key: this.apiKey });\n                }\n                r2 = yield this.transporter.request(opts);\n            }\n            catch (e) {\n                const res = e.response;\n                if (res) {\n                    const statusCode = res.status;\n                    // Retry the request for metadata if the following criteria are true:\n                    // - We haven't already retried.  It only makes sense to retry once.\n                    // - The response was a 401 or a 403\n                    // - The request didn't send a readableStream\n                    // - An access_token and refresh_token were available, but no\n                    //   expiry_date was availabe. This can happen when developers stash\n                    //   the access_token and refresh_token for later use, but the\n                    //   access_token fails on the first try because it's expired.\n                    const mayRequireRefresh = this.credentials &&\n                        this.credentials.access_token && this.credentials.refresh_token &&\n                        !this.credentials.expiry_date;\n                    const isReadableStream = res.config.data instanceof stream.Readable;\n                    const isAuthErr = statusCode === 401 || statusCode === 403;\n                    if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n                        yield this.refreshAccessTokenAsync();\n                        return this.requestAsync(opts, true);\n                    }\n                }\n                throw e;\n            }\n            return r2;\n        });\n    }\n    verifyIdToken(options, callback) {\n        // This function used to accept two arguments instead of an options object.\n        // Check the types to help users upgrade with less pain.\n        // This check can be removed after a 2.0 release.\n        if (callback && typeof callback !== 'function') {\n            throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n        }\n        if (callback) {\n            this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.verifyIdTokenAsync(options);\n        }\n    }\n    verifyIdTokenAsync(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!options.idToken) {\n                throw new Error('The verifyIdToken method requires an ID Token');\n            }\n            const response = yield this.getFederatedSignonCertsAsync();\n            const login = yield this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n            return login;\n        });\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */\n    getTokenInfo(accessToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data } = yield this.transporter.request({\n                method: 'GET',\n                url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n                params: { access_token: accessToken }\n            });\n            const info = Object.assign({\n                expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n                scopes: data.scope.split(' ')\n            }, data);\n            delete info.expires_in;\n            delete info.scope;\n            return info;\n        });\n    }\n    getFederatedSignonCerts(callback) {\n        if (callback) {\n            this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n        }\n        else {\n            return this.getFederatedSignonCertsAsync();\n        }\n    }\n    getFederatedSignonCertsAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const nowTime = (new Date()).getTime();\n            const format = isbrowser_1.isBrowser() ? CertificateFormat.JWK : CertificateFormat.PEM;\n            if (this.certificateExpiry &&\n                (nowTime < this.certificateExpiry.getTime()) &&\n                this.certificateCacheFormat === format) {\n                return { certs: this.certificateCache, format };\n            }\n            let res;\n            let url;\n            switch (format) {\n                case CertificateFormat.PEM:\n                    url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n                    break;\n                case CertificateFormat.JWK:\n                    url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n                    break;\n                default:\n                    throw new Error(`Unsupported certificate format ${format}`);\n            }\n            try {\n                res = yield this.transporter.request({ url });\n            }\n            catch (e) {\n                throw new Error('Failed to retrieve verification certificates: ' + e);\n            }\n            const cacheControl = res ? res.headers['cache-control'] : undefined;\n            let cacheAge = -1;\n            if (cacheControl) {\n                const pattern = new RegExp('max-age=([0-9]*)');\n                const regexResult = pattern.exec(cacheControl);\n                if (regexResult && regexResult.length === 2) {\n                    // Cache results with max-age (in seconds)\n                    cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n                }\n            }\n            let certificates = {};\n            switch (format) {\n                case CertificateFormat.PEM:\n                    certificates = res.data;\n                    break;\n                case CertificateFormat.JWK:\n                    for (const key of res.data.keys) {\n                        certificates[key.kid] = key;\n                    }\n                    break;\n                default:\n                    throw new Error(`Unsupported certificate format ${format}`);\n            }\n            const now = new Date();\n            this.certificateExpiry =\n                cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n            this.certificateCache = certificates;\n            this.certificateCacheFormat = format;\n            return { certs: certificates, format, res };\n        });\n    }\n    verifySignedJwtWithCerts() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */\n    verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const crypto = crypto_1.createCrypto();\n            if (!maxExpiry) {\n                maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n            }\n            const segments = jwt.split('.');\n            if (segments.length !== 3) {\n                throw new Error('Wrong number of segments in token: ' + jwt);\n            }\n            const signed = segments[0] + '.' + segments[1];\n            const signature = segments[2];\n            let envelope;\n            let payload;\n            try {\n                envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n            }\n            catch (err) {\n                throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n            }\n            if (!envelope) {\n                throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n            }\n            try {\n                payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n            }\n            catch (err) {\n                throw new Error('Can\\'t parse token payload: ' + segments[0]);\n            }\n            if (!payload) {\n                throw new Error('Can\\'t parse token payload: ' + segments[1]);\n            }\n            if (!certs.hasOwnProperty(envelope.kid)) {\n                // If this is not present, then there's no reason to attempt verification\n                throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n            }\n            const cert = certs[envelope.kid];\n            const verified = yield crypto.verify(cert, signed, signature);\n            if (!verified) {\n                throw new Error('Invalid token signature: ' + jwt);\n            }\n            if (!payload.iat) {\n                throw new Error('No issue time in token: ' + JSON.stringify(payload));\n            }\n            if (!payload.exp) {\n                throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n            }\n            const iat = Number(payload.iat);\n            if (isNaN(iat))\n                throw new Error('iat field using invalid format');\n            const exp = Number(payload.exp);\n            if (isNaN(exp))\n                throw new Error('exp field using invalid format');\n            const now = new Date().getTime() / 1000;\n            if (exp >= now + maxExpiry) {\n                throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n            }\n            const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n            const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n            if (now < earliest) {\n                throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' +\n                    JSON.stringify(payload));\n            }\n            if (now > latest) {\n                throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' +\n                    JSON.stringify(payload));\n            }\n            if (issuers && issuers.indexOf(payload.iss) < 0) {\n                throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' +\n                    payload.iss);\n            }\n            // Check the audience matches if we have one\n            if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n                const aud = payload.aud;\n                let audVerified = false;\n                // If the requiredAudience is an array, check if it contains token\n                // audience\n                if (requiredAudience.constructor === Array) {\n                    audVerified = (requiredAudience.indexOf(aud) > -1);\n                }\n                else {\n                    audVerified = (aud === requiredAudience);\n                }\n                if (!audVerified) {\n                    throw new Error('Wrong recipient, payload audience != requiredAudience');\n                }\n            }\n            return new loginticket_1.LoginTicket(envelope, payload);\n        });\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */\n    isTokenExpiring() {\n        const expiryDate = this.credentials.expiry_date;\n        return expiryDate ? expiryDate <=\n            ((new Date()).getTime() + this.eagerRefreshThresholdMillis) :\n            false;\n    }\n}\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Clock skew - five minutes in seconds\n */\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];\nexports.OAuth2Client = OAuth2Client;\n//# sourceMappingURL=oauth2client.js.map"]},"metadata":{},"sourceType":"script"}