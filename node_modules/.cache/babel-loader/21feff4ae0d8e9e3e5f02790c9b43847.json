{"ast":null,"code":"\"use strict\"; // Copyright 2020 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _regeneratorRuntime = require(\"/Users/amandapoetker-alles/Desktop/campaign-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/amandapoetker-alles/Desktop/campaign-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.closeSession = exports.request = exports.sessions = void 0;\n\nvar http2 = require(\"http2\");\n\nvar zlib = require(\"zlib\");\n\nvar url_1 = require(\"url\");\n\nvar qs = require(\"qs\");\n\nvar extend = require(\"extend\");\n\nvar stream_1 = require(\"stream\");\n\nvar util = require(\"util\");\n\nvar process = require(\"process\");\n\nvar common_1 = require(\"gaxios/build/src/common\");\n\nvar _http2$constants = http2.constants,\n    HTTP2_HEADER_CONTENT_ENCODING = _http2$constants.HTTP2_HEADER_CONTENT_ENCODING,\n    HTTP2_HEADER_CONTENT_TYPE = _http2$constants.HTTP2_HEADER_CONTENT_TYPE,\n    HTTP2_HEADER_METHOD = _http2$constants.HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH = _http2$constants.HTTP2_HEADER_PATH,\n    HTTP2_HEADER_STATUS = _http2$constants.HTTP2_HEADER_STATUS;\nvar DEBUG = !!process.env.HTTP2_DEBUG;\n/**\n * List of sessions current in use.\n * @private\n */\n\nexports.sessions = {};\nvar warned = false;\n/**\n * Public method to make an http2 request.\n * @param config - Request options.\n */\n\nfunction request(_x) {\n  return _request.apply(this, arguments);\n}\n\nfunction _request() {\n  _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(config) {\n    var message, opts, url, sessionData, pathWithQs, q, headers, res, chunks, session, req;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // Make sure users know this API is unstable\n            if (!warned) {\n              message = \"\\n      The HTTP/2 API in googleapis is unstable! This is an early implementation\\n      that should not be used in production.  It may change in unpredictable\\n      ways. Please only use this for experimentation.\\n    \";\n              process.emitWarning(message, 'GOOG_HTTP2');\n              warned = true;\n            }\n\n            opts = extend(true, {}, config);\n            opts.validateStatus = opts.validateStatus || validateStatus;\n            opts.responseType = opts.responseType || 'json';\n            url = new url_1.URL(opts.url); // Check for an existing session to this host, or go create a new one.\n\n            sessionData = _getClient(url.host); // Since we're using this session, clear the timeout handle to ensure\n            // it stays in memory and connected for a while further.\n\n            if (sessionData.timeoutHandle !== undefined) {\n              clearTimeout(sessionData.timeoutHandle);\n            } // Assemble the querystring based on config.params.  We're using the\n            // `qs` module to make life a little easier.\n\n\n            pathWithQs = url.pathname;\n\n            if (config.params && Object.keys(config.params).length > 0) {\n              q = qs.stringify(opts.params);\n              pathWithQs += \"?\".concat(q);\n            } // Assemble the headers based on basic HTTP2 primitives (path, method) and\n            // custom headers sent from the consumer.  Note: I am using `Object.assign`\n            // here making the assumption these objects are not deep.  If it turns out\n            // they are, we may need to use the `extend` npm module for deep cloning.\n\n\n            headers = Object.assign({}, opts.headers, {\n              [HTTP2_HEADER_PATH]: pathWithQs,\n              [HTTP2_HEADER_METHOD]: config.method || 'GET'\n            }); // NOTE: This is working around an upstream bug in `apirequest.ts`. The\n            // request path assumes that the `content-type` header is going to be set in\n            // the underlying HTTP Client. This hack provides bug for bug compatability\n            // with this bug in gaxios:\n            // https://github.com/googleapis/gaxios/blob/master/src/gaxios.ts#L202\n\n            if (!headers[HTTP2_HEADER_CONTENT_TYPE]) {\n              if (opts.responseType !== 'text') {\n                headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/json';\n              }\n            }\n\n            res = {\n              config,\n              request: {},\n              headers: [],\n              status: 0,\n              data: {},\n              statusText: ''\n            };\n            chunks = [];\n            session = sessionData.session;\n            return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n              try {\n                req = session.request(headers).on('response', function (headers) {\n                  res.headers = headers;\n                  res.status = Number(headers[HTTP2_HEADER_STATUS]);\n                  var stream = req;\n\n                  if (headers[HTTP2_HEADER_CONTENT_ENCODING] === 'gzip') {\n                    stream = req.pipe(zlib.createGunzip());\n                  }\n\n                  if (opts.responseType === 'stream') {\n                    res.data = stream;\n                    resolve(res);\n                    return;\n                  }\n\n                  stream.on('data', function (d) {\n                    chunks.push(d);\n                  }).on('error', function (err) {\n                    reject(err);\n                    return;\n                  }).on('end', function () {\n                    var buf = Buffer.concat(chunks); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n                    var data = buf;\n\n                    if (buf) {\n                      if (opts.responseType === 'json') {\n                        try {\n                          data = JSON.parse(buf.toString('utf8'));\n                        } catch (_a) {\n                          data = buf.toString('utf8');\n                        }\n                      } else if (opts.responseType === 'text') {\n                        data = buf.toString('utf8');\n                      } else if (opts.responseType === 'arraybuffer') {\n                        data = buf.buffer;\n                      }\n\n                      res.data = data;\n                    }\n\n                    if (!opts.validateStatus(res.status)) {\n                      var _message = \"Request failed with status code \".concat(res.status, \". \");\n\n                      if (res.data && typeof res.data === 'object') {\n                        var body = util.inspect(res.data, {\n                          depth: 5\n                        });\n                        _message = \"\".concat(_message, \"\\n'\").concat(body);\n                      }\n\n                      reject(new common_1.GaxiosError(_message, opts, res));\n                    }\n\n                    resolve(res);\n                    return;\n                  });\n                }).on('error', function (e) {\n                  reject(e);\n                  return;\n                });\n              } catch (e) {\n                closeSession(url);\n                reject(e);\n              }\n\n              res.request = req; // If data was provided, write it to the request in the form of\n              // a stream, string data, or a basic object.\n\n              if (config.data) {\n                if (config.data instanceof stream_1.Stream) {\n                  config.data.pipe(req);\n                } else if (typeof config.data === 'string') {\n                  var data = Buffer.from(config.data);\n                  req.end(data);\n                } else if (typeof config.data === 'object') {\n                  var _data = JSON.stringify(config.data);\n\n                  req.end(_data);\n                }\n              } // Create a timeout so the Http2Session will be cleaned up after\n              // a period of non-use. 500 milliseconds was chosen because it's\n              // a nice round number, and I don't know what would be a better\n              // choice. Keeping this channel open will hold a file descriptor\n              // which will prevent the process from exiting.\n\n\n              sessionData.timeoutHandle = setTimeout(function () {\n                closeSession(url);\n              }, 500);\n            }));\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _request.apply(this, arguments);\n}\n\nexports.request = request;\n/**\n * By default, throw for any non-2xx status code\n * @param status - status code from the HTTP response\n */\n\nfunction validateStatus(status) {\n  return status >= 200 && status < 300;\n}\n/**\n * Obtain an existing h2 session or go create a new one.\n * @param host - The hostname to which the session belongs.\n */\n\n\nfunction _getClient(host) {\n  if (!exports.sessions[host]) {\n    if (DEBUG) {\n      console.log(\"Creating client for \".concat(host));\n    }\n\n    var session = http2.connect(\"https://\".concat(host));\n    session.on('error', function (e) {\n      console.error(\"*ERROR*: \".concat(e));\n      delete exports.sessions[host];\n    }).on('goaway', function (errorCode, lastStreamId) {\n      console.error(\"*GOAWAY*: \".concat(errorCode, \" : \").concat(lastStreamId));\n      delete exports.sessions[host];\n    });\n    exports.sessions[host] = {\n      session\n    };\n  } else {\n    if (DEBUG) {\n      console.log(\"Used cached client for \".concat(host));\n    }\n  }\n\n  return exports.sessions[host];\n}\n\nfunction closeSession(_x2) {\n  return _closeSession.apply(this, arguments);\n}\n\nfunction _closeSession() {\n  _closeSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(url) {\n    var sessionData, session;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            sessionData = exports.sessions[url.host];\n\n            if (sessionData) {\n              _context2.next = 3;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 3:\n            session = sessionData.session;\n            delete exports.sessions[url.host];\n\n            if (DEBUG) {\n              console.error(\"Closing \".concat(url.host));\n            }\n\n            session.close(function () {\n              if (DEBUG) {\n                console.error(\"Closed \".concat(url.host));\n              }\n            });\n            setTimeout(function () {\n              if (session && !session.destroyed) {\n                if (DEBUG) {\n                  console.log(\"Forcing close \".concat(url.host));\n                }\n\n                if (session) {\n                  session.destroy();\n                }\n              }\n            }, 1000);\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _closeSession.apply(this, arguments);\n}\n\nexports.closeSession = closeSession;","map":{"version":3,"sources":["/Users/amandapoetker-alles/Desktop/campaign-dashboard/node_modules/googleapis-common/build/src/http2.js"],"names":["Object","defineProperty","exports","value","closeSession","request","sessions","http2","require","zlib","url_1","qs","extend","stream_1","util","process","common_1","constants","HTTP2_HEADER_CONTENT_ENCODING","HTTP2_HEADER_CONTENT_TYPE","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_STATUS","DEBUG","env","HTTP2_DEBUG","warned","config","message","emitWarning","opts","validateStatus","responseType","url","URL","sessionData","_getClient","host","timeoutHandle","undefined","clearTimeout","pathWithQs","pathname","params","keys","length","q","stringify","headers","assign","method","res","status","data","statusText","chunks","session","Promise","resolve","reject","req","on","Number","stream","pipe","createGunzip","d","push","err","buf","Buffer","concat","JSON","parse","toString","_a","buffer","body","inspect","depth","GaxiosError","e","Stream","from","end","setTimeout","console","log","connect","error","errorCode","lastStreamId","close","destroyed","destroy"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2020 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.closeSession = exports.request = exports.sessions = void 0;\nconst http2 = require(\"http2\");\nconst zlib = require(\"zlib\");\nconst url_1 = require(\"url\");\nconst qs = require(\"qs\");\nconst extend = require(\"extend\");\nconst stream_1 = require(\"stream\");\nconst util = require(\"util\");\nconst process = require(\"process\");\nconst common_1 = require(\"gaxios/build/src/common\");\nconst { HTTP2_HEADER_CONTENT_ENCODING, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_STATUS, } = http2.constants;\nconst DEBUG = !!process.env.HTTP2_DEBUG;\n/**\n * List of sessions current in use.\n * @private\n */\nexports.sessions = {};\nlet warned = false;\n/**\n * Public method to make an http2 request.\n * @param config - Request options.\n */\nasync function request(config) {\n    // Make sure users know this API is unstable\n    if (!warned) {\n        const message = `\n      The HTTP/2 API in googleapis is unstable! This is an early implementation\n      that should not be used in production.  It may change in unpredictable\n      ways. Please only use this for experimentation.\n    `;\n        process.emitWarning(message, 'GOOG_HTTP2');\n        warned = true;\n    }\n    const opts = extend(true, {}, config);\n    opts.validateStatus = opts.validateStatus || validateStatus;\n    opts.responseType = opts.responseType || 'json';\n    const url = new url_1.URL(opts.url);\n    // Check for an existing session to this host, or go create a new one.\n    const sessionData = _getClient(url.host);\n    // Since we're using this session, clear the timeout handle to ensure\n    // it stays in memory and connected for a while further.\n    if (sessionData.timeoutHandle !== undefined) {\n        clearTimeout(sessionData.timeoutHandle);\n    }\n    // Assemble the querystring based on config.params.  We're using the\n    // `qs` module to make life a little easier.\n    let pathWithQs = url.pathname;\n    if (config.params && Object.keys(config.params).length > 0) {\n        const q = qs.stringify(opts.params);\n        pathWithQs += `?${q}`;\n    }\n    // Assemble the headers based on basic HTTP2 primitives (path, method) and\n    // custom headers sent from the consumer.  Note: I am using `Object.assign`\n    // here making the assumption these objects are not deep.  If it turns out\n    // they are, we may need to use the `extend` npm module for deep cloning.\n    const headers = Object.assign({}, opts.headers, {\n        [HTTP2_HEADER_PATH]: pathWithQs,\n        [HTTP2_HEADER_METHOD]: config.method || 'GET',\n    });\n    // NOTE: This is working around an upstream bug in `apirequest.ts`. The\n    // request path assumes that the `content-type` header is going to be set in\n    // the underlying HTTP Client. This hack provides bug for bug compatability\n    // with this bug in gaxios:\n    // https://github.com/googleapis/gaxios/blob/master/src/gaxios.ts#L202\n    if (!headers[HTTP2_HEADER_CONTENT_TYPE]) {\n        if (opts.responseType !== 'text') {\n            headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/json';\n        }\n    }\n    const res = {\n        config,\n        request: {},\n        headers: [],\n        status: 0,\n        data: {},\n        statusText: '',\n    };\n    const chunks = [];\n    const session = sessionData.session;\n    let req;\n    return new Promise((resolve, reject) => {\n        try {\n            req = session\n                .request(headers)\n                .on('response', headers => {\n                res.headers = headers;\n                res.status = Number(headers[HTTP2_HEADER_STATUS]);\n                let stream = req;\n                if (headers[HTTP2_HEADER_CONTENT_ENCODING] === 'gzip') {\n                    stream = req.pipe(zlib.createGunzip());\n                }\n                if (opts.responseType === 'stream') {\n                    res.data = stream;\n                    resolve(res);\n                    return;\n                }\n                stream\n                    .on('data', d => {\n                    chunks.push(d);\n                })\n                    .on('error', err => {\n                    reject(err);\n                    return;\n                })\n                    .on('end', () => {\n                    const buf = Buffer.concat(chunks);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    let data = buf;\n                    if (buf) {\n                        if (opts.responseType === 'json') {\n                            try {\n                                data = JSON.parse(buf.toString('utf8'));\n                            }\n                            catch (_a) {\n                                data = buf.toString('utf8');\n                            }\n                        }\n                        else if (opts.responseType === 'text') {\n                            data = buf.toString('utf8');\n                        }\n                        else if (opts.responseType === 'arraybuffer') {\n                            data = buf.buffer;\n                        }\n                        res.data = data;\n                    }\n                    if (!opts.validateStatus(res.status)) {\n                        let message = `Request failed with status code ${res.status}. `;\n                        if (res.data && typeof res.data === 'object') {\n                            const body = util.inspect(res.data, { depth: 5 });\n                            message = `${message}\\n'${body}`;\n                        }\n                        reject(new common_1.GaxiosError(message, opts, res));\n                    }\n                    resolve(res);\n                    return;\n                });\n            })\n                .on('error', e => {\n                reject(e);\n                return;\n            });\n        }\n        catch (e) {\n            closeSession(url);\n            reject(e);\n        }\n        res.request = req;\n        // If data was provided, write it to the request in the form of\n        // a stream, string data, or a basic object.\n        if (config.data) {\n            if (config.data instanceof stream_1.Stream) {\n                config.data.pipe(req);\n            }\n            else if (typeof config.data === 'string') {\n                const data = Buffer.from(config.data);\n                req.end(data);\n            }\n            else if (typeof config.data === 'object') {\n                const data = JSON.stringify(config.data);\n                req.end(data);\n            }\n        }\n        // Create a timeout so the Http2Session will be cleaned up after\n        // a period of non-use. 500 milliseconds was chosen because it's\n        // a nice round number, and I don't know what would be a better\n        // choice. Keeping this channel open will hold a file descriptor\n        // which will prevent the process from exiting.\n        sessionData.timeoutHandle = setTimeout(() => {\n            closeSession(url);\n        }, 500);\n    });\n}\nexports.request = request;\n/**\n * By default, throw for any non-2xx status code\n * @param status - status code from the HTTP response\n */\nfunction validateStatus(status) {\n    return status >= 200 && status < 300;\n}\n/**\n * Obtain an existing h2 session or go create a new one.\n * @param host - The hostname to which the session belongs.\n */\nfunction _getClient(host) {\n    if (!exports.sessions[host]) {\n        if (DEBUG) {\n            console.log(`Creating client for ${host}`);\n        }\n        const session = http2.connect(`https://${host}`);\n        session\n            .on('error', e => {\n            console.error(`*ERROR*: ${e}`);\n            delete exports.sessions[host];\n        })\n            .on('goaway', (errorCode, lastStreamId) => {\n            console.error(`*GOAWAY*: ${errorCode} : ${lastStreamId}`);\n            delete exports.sessions[host];\n        });\n        exports.sessions[host] = { session };\n    }\n    else {\n        if (DEBUG) {\n            console.log(`Used cached client for ${host}`);\n        }\n    }\n    return exports.sessions[host];\n}\nasync function closeSession(url) {\n    const sessionData = exports.sessions[url.host];\n    if (!sessionData) {\n        return;\n    }\n    const { session } = sessionData;\n    delete exports.sessions[url.host];\n    if (DEBUG) {\n        console.error(`Closing ${url.host}`);\n    }\n    session.close(() => {\n        if (DEBUG) {\n            console.error(`Closed ${url.host}`);\n        }\n    });\n    setTimeout(() => {\n        if (session && !session.destroyed) {\n            if (DEBUG) {\n                console.log(`Forcing close ${url.host}`);\n            }\n            if (session) {\n                session.destroy();\n            }\n        }\n    }, 1000);\n}\nexports.closeSession = closeSession;\n//# sourceMappingURL=http2.js.map"]},"metadata":{},"sourceType":"script"}